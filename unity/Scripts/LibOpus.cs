using System;
using System.Runtime.InteropServices;

using opus_int16 = System.Int16;
using opus_int32 = System.Int32;

namespace Libopus
{
    public static class LibraryWrapper
    {
#if UNITY_STANDALONE_WIN || UNITY_EDITOR_WIN
        const string dllName = "opus.dll";
#else
        const string dllName = "libopus";
#endif
        public enum EncoderCtlID
        {
            SetApplicationRequest = 4000,
            GetApplicationRequest,
            SetBitrateRequest,
            GetBitrateRequest,
            SetMaxBandwidthRequest,
            GetMaxBandwidthRequest,
            SetVBRRequest,
            GetVBRRequest,
            SetBandwidthRequest,
            GetBandwidthRequest,
            SetComplexityRequest,
            GetComplexityRequest,
            SetInbandFECRequest,
            GetInbandFECRequest,
            SetPacketLossPercRequest,
            GetPacketLossPercRequest,
            SetDTXRequest,
            GetDTXRequest,
            SetVBRConstraintRequest = 4020,
            GetVBRConstraintRequest,
            SetForceChannelsRequest,
            GetForceChannelsRequest,
            SetSignalRequest,
            GetSignalRequest,
            GetLookAheadRequest = 4027,
            ResetState = 4028,
            GetSampleRateRequest = 4029,
            GetFinalRangeRequest = 4031,
            GetPitchRequest = 4033,
            SetGainRequest = 4034,
            GetGainRequest = 4045,
            SetLSBDepthRequest = 4036,
            GetLSBDepthRequest = 4037,
            GetLastPacketDurationRequest = 4039,
            SetExpertFrameDurationRequest = 4040,
            GetExpertFrameDurationRequest = 4041,
            SetPreditionDisabledRequest = 4042,
            GetPreditionDisabledRequest = 4043,
            SetPhaseInversionDisabledRequest = 4046,
            GetPhaseInversionDisabledRequest = 4047,
            GetInDTXRequest = 4049,
            SetDREDDurationRequest = 4050,
            GetDREDDurationRequest = 4051,
            SetDNNBlobRequest = 4052,
        }

        #region Encoder
        /// <summary>
        /// Allocates and initializes an encoder state.
        /// </summary>
        /// <param name="Fs">Sampling rate of input signal (Hz)</param>
        /// <param name="channels">Number of channels (1 or 2) in input signal</param>
        /// <param name="application">Coding mode</param>
        /// <param name="error">Error codes</param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern IntPtr opus_encoder_create(SamplingRate Fs, int channels, Application application, ref ErrorCode error);

        /// <summary>
        /// Encodes an Opus frame.
        /// </summary>
        /// <param name="encoder">Encoder state</param>
        /// <param name="pcm"> Input signal (interleaved if 2 channels). length is frame_size∗channels∗sizeof(opus_int16)</param>
        /// <param name="frame_size">Number of samples per channel in the input signal. This must be an Opus frame size for the encoder's sampling rate.</param>
        /// <param name="data">Output payload. This must contain storage for at least max_data_bytes.</param>
        /// <param name="max_data_bytes">Size of the allocated memory for the output payload.</param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern opus_int32 opus_encode(IntPtr encoder, opus_int16[] pcm, int frame_size, byte[] data, opus_int32 max_data_bytes);

        /// <summary>
        /// Encodes an Opus frame.
        /// </summary>
        /// <param name="encoder">Encoder state</param>
        /// <param name="pcm">Input in float format (interleaved if 2 channels), with a normal range of +/-1.0. length is frame_size∗channels∗sizeof(float) </param>
        /// <param name="frame_size">Number of samples per channel in the input signal. This must be an Opus frame size for the encoder's sampling rate.</param>
        /// <param name="data">Output payload. This must contain storage for at least max_data_bytes.</param>
        /// <param name="max_data_bytes">Size of the allocated memory for the output payload.</param>
        [DllImport(dllName)]
        public static extern opus_int32 opus_encode_float(IntPtr encoder, float[] pcm, int frame_size, byte[] data, opus_int32 max_data_bytes);

        /// <summary>
        /// Perform a CTL function on an Opus encoder.
        /// Generally the request and subsequent arguments are generated by a convenience macro.
        /// </summary>
        /// <param name="encoder">Encoder state</param>
        /// <param name="request">This and all remaining parameters should be replaced by one of the convenience macros in Generic CTLs or Encoder related CTLs.</param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_encoder_ctl(IntPtr encoder, EncoderCtlID request, opus_int32 param1);

        /// <summary>
        /// Perform a CTL function on an Opus encoder.
        /// Generally the request and subsequent arguments are generated by a convenience macro.
        /// </summary>
        /// <param name="encoder">Encoder state</param>
        /// <param name="request">This and all remaining parameters should be replaced by one of the convenience macros in Generic CTLs or Encoder related CTLs.</param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_encoder_ctl(IntPtr encoder, EncoderCtlID request, ref opus_int32 param1);

        /// <summary>
        /// Frees an OpusEncoder allocated by opus_encoder_create().
        /// </summary>
        /// <param name="encoder"></param>
        [DllImport(dllName)]
        public static extern void opus_encoder_destroy(IntPtr encoder);
        #endregion
        #region Decoder
        /// <summary>
        /// Allocates and initializes a decoder state.
        /// </summary>
        /// <param name="Fs"></param>
        /// <param name="channels"></param>
        /// <param name="error"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern IntPtr opus_decoder_create(SamplingRate Fs, int channels, ref ErrorCode error);
        /// <summary>
        /// Decode an Opus packet.
        /// </summary>
        /// <param name="decoder">Decoder state</param>
        /// <param name="data">Input payload. Use a NULL pointer to indicate packet loss</param>
        /// <param name="len">Number of bytes in payload</param>
        /// <param name="pcm"> Output signal (interleaved if 2 channels). length is frame_size∗channels∗sizeof(opus_int16)</param>
        /// <param name="frame_size">Number of samples per channel of available space in pcm. If this is less than the maximum packet duration(120ms; 5760 for 48kHz), this function will not be capable of decoding some packets. </param>
        /// <param name="decode_fec"> Flag (0 or 1) to request that any in-band forward error correction data be decoded. If no such data is available, the frame is decoded as if it were lost.</param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_decode(IntPtr decoder, byte[] data, opus_int32 len, opus_int16[] pcm, int frame_size, int decode_fec);
        /// <summary>
        /// Decode an Opus packet with floating point output.
        /// </summary>
        /// <param name="decoder"></param>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <param name="pcm"></param>
        /// <param name="frame_size"></param>
        /// <param name="decode_fec"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_decode_float(IntPtr decoder, byte[] data, opus_int32 len, float[] pcm, int frame_size, int decode_fec);
        /// <summary>
        /// Perform a CTL function on an Opus decoder.
        /// Generally the request and subsequent arguments are generated by a convenience macro.
        /// </summary>
        /// <param name="encoder">Encoder state</param>
        /// <param name="request">This and all remaining parameters should be replaced by one of the convenience macros in Generic CTLs or Encoder related CTLs.</param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_decoder_ctl(IntPtr decoder, EncoderCtlID request, opus_int32 param1);

        /// <summary>
        /// Perform a CTL function on an Opus decoder.
        /// Generally the request and subsequent arguments are generated by a convenience macro.
        /// </summary>
        /// <param name="encoder">Encoder state</param>
        /// <param name="request">This and all remaining parameters should be replaced by one of the convenience macros in Generic CTLs or Encoder related CTLs.</param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_decoder_ctl(IntPtr decoder, EncoderCtlID request, ref opus_int32 param1);

        /// <summary>
        /// Frees an OpusDecoder allocated by opus_decoder_create().
        /// </summary>
        /// <param name="decoder"></param>
        [DllImport(dllName)]
        public static extern void opus_decoder_destroy(IntPtr decoder);

        /// <summary>
        /// Gets the number of samples of an Opus packet.
        /// </summary>
        /// <param name="decoder"></param>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_decoder_get_nb_samples(IntPtr decoder, byte[] data, opus_int32 len);

        /// <summary>
        /// Applies soft-clipping to bring a float signal within the [-1,1] range.
        /// </summary>
        /// <param name="pcm">Input PCM and modified PCM</param>
        /// <param name="frame_size"> Number of samples per channel to process</param>
        /// <param name="channels">Number of channels</param>
        /// <param name="softclip_mem">State memory for the soft clipping process (one float per channel, initialized to zero)</param>
        [DllImport(dllName)]
        public static extern void opus_pcm_soft_clip(float[] pcm, int frame_size, int channels, float[] softclip_mem);
        #endregion
        #region PacketInfo
        /// <summary>
        /// Parse an opus packet into one or more frames.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <param name="out_toc"></param>
        /// <param name="frames"></param>
        /// <param name="size"></param>
        /// <param name="payload_offset"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_packet_parse(byte[] data, opus_int32 len, byte[] out_toc, byte[] frames, opus_int16[] size, ref int payload_offset);

        /// <summary>
        /// Gets the bandwidth of an Opus packet.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_packet_get_bandwidth(byte[] data);
        /// <summary>
        /// Gets the number of samples per frame from an Opus packet.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="fs"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_packet_get_samples_per_frame(byte[] data, SamplingRate fs);
        /// <summary>
        /// Gets the number of channels from an Opus packet.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_packet_get_nb_channels(byte[] data);
        /// <summary>
        /// Gets the number of frames in an Opus packet.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_packet_get_nb_frames(byte[] data, opus_int32 len);
        /// <summary>
        /// Gets the number of samples of an Opus packet.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <param name="fs"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_packet_get_nb_samples(byte[] data, opus_int32 len, SamplingRate fs);
        /// <summary>
        /// Checks whether an Opus packet has LBRR.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <returns></returns>
        [DllImport(dllName)]
        public static extern int opus_packet_has_lbrr(byte[] data, opus_int32 len);
        #endregion
        #region Information
        /// <summary>
        /// Converts an opus error code into a human readable string.
        /// </summary>
        /// <param name="err">Error number</param>
        /// <returns>Error string</returns>
        [DllImport(dllName)]
        public static extern string opus_strerror(ErrorCode err);

        /// <summary>
        /// Gets the libopus version string.
        /// </summary>
        /// <returns>Version string</returns>
        [DllImport(dllName)]
        public static extern string opus_get_version_string();
        #endregion
        #region CTLWrapper
        /// <summary>
        /// Configures the encoder's computational complexity.
        /// The supported range is 0-10 inclusive with 10 representing the highest complexity.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="complexity">Allowed values: 0-10, inclusive.</param>
        /// <returns></returns>
        public static int opus_set_complexity(IntPtr encoder, opus_int32 complexity)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetComplexityRequest, complexity);
        }

        /// <summary>
        /// Gets the encoder's complexity configuration.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="complexity">Allowed values: 0-10, inclusive.</param>
        /// <returns></returns>
        public static int opus_get_complexity(IntPtr encoder, ref opus_int32 complexity)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.GetComplexityRequest, ref complexity);
        }

        /// <summary>
        /// Configures the bitrate in the encoder.
        /// Rates from 500 to 512000 bits per second are meaningful, as well as the
        /// special values #OPUS_AUTO and #OPUS_BITRATE_MAX.
        /// The value #OPUS_BITRATE_MAX can be used to cause the codec to use as much
        /// rate as it can, which is useful for controlling the rate by adjusting the
        /// output buffer size.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="bitrate">Bitrate in bits per second. The default is determined based on the number of channels and the input sampling rate.</param>
        /// <returns></returns>
        public static int opus_set_bitrate(IntPtr encoder, opus_int32 bitrate)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetBitrateRequest, bitrate);
        }

        public static int opus_get_bitrate(IntPtr encoder, ref opus_int32 bitrate)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.GetBitrateRequest, ref bitrate);
        }

        /// <summary>
        /// Enables or disables variable bitrate (VBR) in the encoder.
        /// The configured bitrate may not be met exactly because frames must
        /// be an integer number of bytes in length.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="vbr">Is VBR (default) or Hard CBR</param>
        /// <returns></returns>
        public static int opus_set_vbr(IntPtr encoder, bool vbr)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetVBRRequest, vbr ? 1 : 0);
        }

        public static int opus_get_vbr(IntPtr encoder, out bool vbr)
        {
            int val = 0;
            int ret = opus_encoder_ctl(encoder, EncoderCtlID.GetVBRRequest, ref val);
            vbr = val == 1;
            return ret;
        }

        /// <summary>
        /// Enables or disables constrained VBR in the encoder.
        /// This setting is ignored when the encoder is in CBR mode.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="constrained">Is Constrained VBR (default) or Unconstrained VBR. This creates a maximum of one frame of buffering delay assuming a transport with a serialization speed of the nominal bitrate.</param>
        /// <returns></returns>
        public static int opus_set_vbr_constraint(IntPtr encoder, bool constrained)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetVBRConstraintRequest, constrained ? 1 : 0);
        }

        public static int opus_get_vbr_constraint(IntPtr encoder, out bool constrained)
        {
            int val = 0;
            int ret = opus_encoder_ctl(encoder, EncoderCtlID.GetVBRConstraintRequest, ref val);
            constrained = val == 1;
            return ret;
        }

        /// <summary>
        /// Configures the maximum bandpass that the encoder will select automatically.
        /// Applications should normally use this instead of #OPUS_SET_BANDWIDTH
        /// (leaving that set to the default, #OPUS_AUTO). This allows the
        /// application to set an upper bound based on the type of input it is
        /// providing, but still gives the encoder the freedom to reduce the bandpass
        /// when the bitrate becomes too low, for better overall quality.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="max_bandwidth"></param>
        /// <returns></returns>
        public static int opus_set_max_bandwidth(IntPtr encoder, Bandwidth max_bandwidth)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetMaxBandwidthRequest, (int)max_bandwidth);
        }

        public static int opus_get_max_bandwidth(IntPtr encoder, out Bandwidth max_bandwidth)
        {
            int bw = 0;
            int ret = opus_encoder_ctl(encoder, EncoderCtlID.GetMaxBandwidthRequest, ref bw);
            max_bandwidth = (Bandwidth)bw;
            return ret;
        }

        /// <summary>
        /// Sets the encoder's bandpass to a specific value.
        /// This prevents the encoder from automatically selecting the bandpass based
        /// on the available bitrate. If an application knows the bandpass of the input
        /// audio it is providing, it should normally use #OPUS_SET_MAX_BANDWIDTH
        /// instead, which still gives the encoder the freedom to reduce the bandpass
        /// when the bitrate becomes too low, for better overall quality.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="bandwidth"></param>
        /// <returns></returns>
        public static int opus_set_bandwidth(IntPtr encoder, Bandwidth bandwidth)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetBandwidthRequest, (int)bandwidth);
        }

        public static int opus_get_bandwidth(IntPtr encoder, out Bandwidth bandwidth)
        {
            int bw = 0;
            int ret = opus_encoder_ctl(encoder, EncoderCtlID.GetBandwidthRequest, ref bw);
            bandwidth = (Bandwidth)bw;
            return ret;
        }

        /// <summary>
        /// Configures the type of signal being encoded.
        /// This is a hint which helps the encoder's mode selection.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="signal"></param>
        /// <returns></returns>
        public static int opus_set_signal(IntPtr encoder, Signal signal)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetSignalRequest, (int)signal);
        }

        public static int opus_get_signal(IntPtr encoder, out Signal signal)
        {
            int sig = 0;
            int ret = opus_encoder_ctl(encoder, EncoderCtlID.GetSignalRequest, ref sig);
            signal = (Signal)sig;
            return ret;
        }

        /// <summary>
        /// Configures the encoder's intended application.
        /// The initial value is a mandatory argument to the encoder_create function.
        /// </summary>
        /// <param name="encoder"></param>
        /// <param name="application"></param>
        /// <returns></returns>
        public static int opus_set_application(IntPtr encoder, Application application)
        {
            return opus_encoder_ctl(encoder, EncoderCtlID.SetApplicationRequest, (int)application);
        }

        #endregion
    }

    public enum SamplingRate : opus_int32
    {
        Rate_8kHz = 8000,
        Rate_12kHz = 12000,
        Rate_16kHz = 16000,
        Rate_24kHz = 24000,
        Rate_48kHz = 48000,
    }

    public enum Application : int
    {
        /// <summary>
        /// Best for most VoIP/videoconference applications where listening quality and intelligibility matter most.
        /// </summary>
        Voip = 2048,
        /// <summary>
        /// Best for broadcast/high-fidelity application where the decoded audio should be as close as possible to the input.
        /// </summary>
        Audio = 2049,
        /// <summary>
        /// Only use when lowest-achievable latency is what matters most.
        /// </summary>
        RestrictedLowDelay = 2051,
    }

    public enum ErrorCode : int
    {
        /// <summary>
        /// No error.
        /// </summary>
        OK = 0,
        /// <summary>
        /// One or more invalid/out of range arguments.
        /// </summary>
        BadArg = -1,
        /// <summary>
        /// Not enough bytes allocated in the buffer.
        /// </summary>
        BufferTooSmall = -2,
        /// <summary>
        /// An internal error was detected.
        /// </summary>
        InternalError = -3,
        /// <summary>
        /// The compressed data passed is corrupted.
        /// </summary>
        InvalidPacket = -4,
        /// <summary>
        /// Invalid/unsupported request number.
        /// </summary>
        Unimplemented = -5,
        /// <summary>
        /// An encoder or decoder structure is invalid or already freed.
        /// </summary>
        InvalidState = -6,
        /// <summary>
        /// Memory allocation has failed.
        /// </summary>
        AllocFail = -7,
    }

    public enum Bandwidth : opus_int32
    {
        Auto = -1000,
        /// <summary>
        /// 4 kHz passband
        /// </summary>
        NarrowBand = 1101,
        /// <summary>
        /// 6 kHz passband
        /// </summary>
        MediumBand,
        /// <summary>
        /// 8 kHz passband
        /// </summary>
        WideBand,
        /// <summary>
        /// 12 kHz passband
        /// </summary>
        SuperWideBand,
        /// <summary>
        /// 20 kHz passband
        /// </summary>
        FullBand
    }

    public enum Signal
    {
        Auto = -1000,
        /// <summary>
        /// Signal being encoded is voice
        /// </summary>
        Voice = 3001,
        /// <summary>
        /// Signal being encoded is music
        /// </summary>
        Music = 3002
    }

    public enum FrameSize
    {
        /// <summary>
        /// Select frame size from the argument (default)
        /// </summary>
        FromArg = 5000,
        /// <summary>
        /// Use 2.5 ms frames
        /// </summary>
        Size2_5ms,
        /// <summary>
        /// Use 5 ms frames
        /// </summary>
        Size5ms,
        /// <summary>
        /// Use 10 ms frames
        /// </summary>
        Size10ms,
        /// <summary>
        /// Use 20 ms frames
        /// </summary>
        Size20ms,
        /// <summary>
        /// Use 40 ms frames
        /// </summary>
        Size40ms,
        /// <summary>
        /// Use 60 ms frames
        /// </summary>
        Size60ms,
        /// <summary>
        /// Use 80 ms frames
        /// </summary>
        Size80ms,
        /// <summary>
        /// Use 100 ms frames
        /// </summary>
        Size100ms,
        /// <summary>
        /// Use 120 ms frames
        /// </summary>
        Size120ms,
    }


    [Serializable]
    public class LibopusException : Exception
    {
        public ErrorCode ErrorCode { get; }
        public LibopusException(ErrorCode code) : base(LibraryWrapper.opus_strerror(code))
        {
            ErrorCode = code;
        }
    }
}
